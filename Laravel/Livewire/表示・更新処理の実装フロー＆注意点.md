# 表示
## 値バインドの基本構造
* モデルをそのまま代入すると同期されない
* `$this->selectedTask = Task::findOrFail($id);`...❌
<br>

* 配列に変換してバインドする✅
```
$task = Task::findOrFail($id);
$this->selectedTask = $task->toArray();
```
<br><br>

## 配列バインド時の更新処理
* Eloquentモデルではなく配列のため、`$this->selectedTask->save();`使用不可❌
<br>

* update()で更新する...`Task::find($this->selectedTask['id'])->update($validated['selectedTask']);`✅
<br><br>

# 更新
## FormRequestをstoreとupdateで使いまわす場合
### 問題点
FormRequestのルールキーは title、description など、store時のキーになっているが、  
Livewire側では表示用に配列で渡した際、 selectedTask.title のような階層構造になるため、  
キーがズレてバリデーションやエラーメッセージが効かなくなる。
<br>

### 対応：キーを動的に変換
```
$request = new TaskRequest();

$rules = collect($request->rules())
    ->mapWithKeys(fn($rule, $key) => ["selectedTask.$key" => $rule])
    ->toArray();

$messages = collect($request->messages())
    ->mapWithKeys(fn($msg, $key) => ["selectedTask.$key" => $msg])
    ->toArray();

$validated = $this->validate($rules, $messages);
```
* rulesとmessagesに対し、両方とも変換した状態で変数に格納。

### 表示兼更新フォームの変換
```
 <form wire:submit.prevent="update" class="detail-form" novalidate>
    <table class="detail-table">
        <tr class="detail-table__row">
            <th class="detail-table__header">タイトル</th>
                <td class="detail-table__item">
                    <input wire:model.defer="selectedTask.title" type="text">
                </td>
                @error('selectedTask.title')
                <td class="error">{{ $message }}</td>
                @enderror

                // 中略

    </table>
    <div class="button__wrapper">
        <button class="update-button" type="submit">更新</button>
        <button class="delete-button" type="button">削除</button>
    </div>
</form>
```
* エラーメッセージのキー...`selectedTask.title`
* deferでボタンクリックまで通信を制限
* formタグなしでも`button wire:click="update"`で動作可能
    * HTMLのバリデーションを無効化し、カスタムしたバリデーションのみ表示させたい時は、novalidate指定の為にformタグ使用推奨。
<br><br>

## バリデーションとDB設計の整合性
| ケース                            | 推奨設定                               | 理由                                        |
| ------------------------------ | ---------------------------------- | ----------------------------------------- |
| DBで `default('doing')` を設定している | FormRequestでは `'nullable'` にする     | storeで未入力でもDBのdefault値が適用される              |
| update時のみ必須にしたい                | update側でルールを上書き                    | Livewireはroute判定が使いにくいため、動的上書きが安全         |
| プロパティ未定義エラーを防ぐ                 | `public $status = 'doing';` のように定義 | `$this->validate()`がpublicプロパティを検証対象にするため |
<br><br>

# 表示から更新処理実装まで
## よくあるハマりポイント
| 問題                   | 原因                              | 対策                                           |
| -------------------- | ------------------------------- | -------------------------------------------- |
| 値が反映されない             | Eloquentモデルを直接代入                | `$task->toArray()`で配列化                       |
| 更新が保存されない            | `$this->selectedTask->save()`使用 | `Task::find()->update()`で対応                  |
| エラーメッセージが英語で出る       | FormRequestのキーとズレている            | `mapWithKeys`でprefix対応                       |
| `status`が更新されない      | ルールに含まれていない                     | `'status' => ['nullable','in:doing,done']`追加 |
| storeでエラー（status未定義） | Livewireに`$status`がない           | `public $status = 'doing';`で定義               |
<br><br>

## Carbonを扱う場合
配列にそのまま入れるとエラーが出るため、配列に入れる前にstring化（またはモデルcast）する。
```
// App\Models\Task.php
protected $casts = [
    'due_date' => 'datetime:Y-m-d',
];
```

```
// Livewireコンポーネント
public function showDetail($id)
{
    $this->selectedTask = Task::findOrFail($id)->toArray();
}
```
<br><br>

## 総括
* Livewireは「配列バインド＋update()」で扱う
* FormRequestを共用するならキー変換（mapWithKeys）が必須
* nullable + DB defaultで責務を分離
* バリデーション対象はpublicプロパティとして定義
* Bladeのエラーは @error('selectedTask.xxx')