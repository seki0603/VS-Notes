# 非同期処理の必要性
JavaScriptは シングルスレッド（1人作業） のため、
重い処理を待っている間に UIが固まるとユーザーが操作できなくなる。

## 重い処理の例
* API通信（サーバーにデータ取りに行く）
* 画像／動画の読み込み
* タイマー処理
* 大量データの計算

<br>

# 同期と非同期の違い
## 同期(Synchronous)
完了するまで次の処理に進まない
➡ UIが止まる可能性がある。
```
const data = getData();
console.log(data); // 取得が終わってから表示
```

## 非同期(Asynchronous)
処理を“裏でやっておいて”、終わったら続きを実行
➡ UIが止まらない。
```
getData().then(data => {
  console.log(data);
});
```

<br>

# Promiseとは
後で結果が届く箱...時間がかかる処理を包むオブジェクト
```
const p = fetch('/api/users'); // これはすぐ返ってくる（Promise）
p.then(res => res.json()).then(data => console.log(data));
```

## Promiseの状態
* pending...処理中
* fulfilled...成功
* rejected...失敗

<br>

# async/awaitの本質
Promiseを読みやすくする文法（現場で主流）
例：Promiseチェーンの場合
```
fetchUser()
  .then(u => fetchPosts(u))
  .then(posts => console.log(posts));
```

例：async/awaitの場合
```
const user = await fetchUser();
const posts = await fetchPosts(user);
console.log(posts);
```

<br>

# イベントループとは
重たい処理を裏で実行し、終わったら結果を返す仕組み

## JavaScriptの処理の流れ
1. コードを上から実行（コールスタック）
2. 時間のかかる処理は WebAPI に渡す（ブラウザの裏側）
3. 完了したら「タスクキュー」に結果を入れる
4. コールスタックが空いたタイミングで結果を実行する
    * コールバック、Promise、async/await が再開する

<br>

# 非同期が必要になる例
* APIからデータ取得
```
const res = await fetch('/api/items');
const items = await res.json();
```

* 画像アップロード/プレビュー表示
    * EC・SNSで必須
* 入力ごとの検索サジェスト
    * Googleの予測変換など
* スクロール時の追加読み込み(無限スクロール)
* チャットの自動更新
    * 新着メッセージのポーリング
* フロント側での重い計算
    * Excelみたいな表計算やPDF生成など