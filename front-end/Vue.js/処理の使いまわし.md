# composable
Vueの独自処理(watchEffect等)を含む、部分的に切り出された関数をcomposableという。
<br>

## composableによる処理の使いまわし
refHistory.js(composableファイル)
```
import { ref, watchEffect } from 'vue'

export function useRefHistory(source) {
  const history = ref([])

  watchEffect(() => {
    history.value.push(source.value)
  })
  function undo() {
    if (history.value.length === 1) return
    history.value.pop()
    source.value = history.value.pop()
  }
  return { history, undo }
}
```
* composableを独立したファイルに記述
* 記述した処理をexport
<br>

App.vue(composableを使うファイル)
```
<script setup>
import { ref } from 'vue'
import { useRefHistory } from './composables/refHistory'

const count = ref(0)

const { history, undo } = useRefHistory(count)
const userInput = ref('')
const { history: history2, undo: undo2 } = useRefHistory(userInput)
</script>
```
* composableファイルをインポート
* 処理を使う定数を定義
<br>

## composable同士の組み合わせ
1. refHistory.js(処理１に該当するcomposable)を作成
<br>

2. refLimitedHistory.js(処理２に該当するファイルを作成)
```
import { watchEffect, toValue } from "vue"
import { useRefHistory } from "./refHistory"

export function useRefLimitedHistory(source, capacity) {
  const { history, undo } = useRefHistory(source)
  watchEffect(() => {
    if (history.value.length > toValue(capacity)) {
      history.value.shift()
    }
  })
  return { history, undo }
}
```
* 処理１に該当するcomposableをインポート
* 処理２の内容を記述し、エクスポート
<br>

3. 組み合わせた処理をvueファイルにインポート
```
<script setup>
import { ref } from 'vue'
import { useRefLimitedHistory } from './composables/refLimitedHistory'

const count = ref(0)

const { history, undo } = useRefLimitedHistory(count, 3)
const userInput = ref('')
const { history: history2, undo: undo2 } = useRefLimitedHistory(userInput, 6)
</script>
```
<br>

## composableのベストプラクティス
* 関数名はuseから始める
* 引数にrefオブジェクトではない値が期待されるとき、refオブジェクトで渡されても動く処理を記述するべき
    * toValueを利用
* 返り値が複数ある場合、オブジェクトのプロパティとして返す
<br>

### toValue関数の役割
* 引数にrefオブジェクトではない値が入った時...値をそのまま返す
* 引数にrefオブジェクトが入った時...値にvalueをつけて返す